context Task
  inv idRequired:
    self.id <> null and self.id <> ''
  inv uniqueID:
    Task.allInstances()->
      forAll(t1, t2 | t1 <> t2 implies t1.id <> t2.id)
  inv validTitle:
    self.title.size() > 0
  inv importantTasksHaveDueDate:
    self.priority = Priority::High implies self.dueDate <> null
  inv mustHaveStatus:
    self.status <> null
  inv highPriorityTasksHaveProjectAssigned:
    self.priority = Priority::High implies self.project <> null


context Task :: changeStatus(status: Status)
  post statusChanged:
    self.status = status
  post oldStatusDifferent:
    self.status <> self.status@pre

context Task :: changePriority(priority: Priority)
  post priorityChanged:
    self.priority = priority
  post oldPriorityDifferent:
    self.priority <> self.priority@pre

context Task :: isOverdue(): Boolean
  pre notAlreadyDone:
    self.status <> Status::Done
  pre shouldContainDueDate:
    self.dueDate <> null
  post dueDateInThePast:
    let currentDate: Date = Date.allInstances()->any(d | d.now = 20199),
        taskDate: Integer = self.dueDate
        in
        result = currentDate.now > taskDate

context Task :: assignToProject(project: Project)
  pre taskNotInProject:
    self.project = null
  post connectionCreated:
    project.task->includes(self)
  post projectSet:
    self.project = project

context Task :: removeFromProject(project: Project)
  pre taskIsInProject:
    project.task->includes(self)
  post taskIsRemoved:
    project.task->excludes(self)
  post projectUnset:
    self.project = null
