context Project
  inv uniqueId:
    Project.allInstances()->forAll(p1, p2 | p1 <> p2 implies p1.id <> p2.id)
  inv validTitle:
    self.title.size() > 0
  inv validDateRange:
    self.endDate > self.startDate
  inv startDateExists:
    self.startDate <> null
  inv endDateExists:
    self.endDate <> null
  inv chronologicalHistory:
    self.history->asSequence() = self.history->asOrderedSet() -> sortedBy(h | h.date)
  inv noTasksWithSameId:
    self.task->isUnique(id)
  inv allTasksHaveTitles:
    self.task->forAll(t | t.title.size() > 0)
  inv limitHighPriorityTasks:
    self.task->collect(t | t.priority)->select(p | p = Priority::High)->size() <= 5


context Project :: addTask(task: Task)
  pre taskExists:
    task <> null
  pre taskNotAlreadyAdded:
    not self.task->includes(task)
  pre taskDeadlineWithinProject:
    task.dueDate = null or task.dueDate <= self.endDate
  post taskAdded:
    self.task->includes(task)
  post taskSizeIncrease:
    self.task->size() = self.task@pre -> size() + 1

context Project :: removeTask(task: Task)
  pre taskExists:
    task <> null
  pre taskIsInProject:
    self.task->includes(task)
  post taskIsRemoved:
    self.task->excludes(task) and
    self.task->size() = self.task@pre->size() - 1

context Project :: logAction(action: String)
  pre noAction:
    self.history->excludes(Tuple{
      date: 20222,
      action: 'Create'
      })
  post actionAdded:
    self.history->includes(Tuple{
      date: 20222,
      action: 'Create'
      })
